---
title: Simple models
output: html_notebook
encoding: utf8
---

```{r, echo=FALSE, results="hide", message=FALSE}
library(tidyr)
library(dplyr)
library(tsibble)
library(feasts)
library(fable)
```

We fit some simple models to the orange juice data. One model is fit for each combination of store and brand.

- `mean`: This is just a simple mean.
- `naive`: A random walk model without any other components. This amounts to setting all forecast values to the last observed value.
- `drift`: This adjusts the `naive` model to incorporate a trend.
- `arima`: An ARIMA model with the parameter values estimated from the data.
- `ets`: An exponentially weighted model, again with parameter values estimated from the data.

```{r}
load("oj_data.Rdata")

# train the models in parallel
ncores <- max(2, parallel::detectCores(logical=FALSE) - 2)
cl <- parallel::makeCluster(ncores)
invisible(parallel::clusterEvalQ(cl,
{
    library(tidyr)
    library(feasts)
    library(fable)
    library(tsibble)
}))

# we have multiple training sets, so parallelise by dataset
# first, fit models that can handle missing values
oj_modelset <- parallel::parLapply(cl, oj_train, function(df)
{
    model(df,
        mean=MEAN(logmove),
        naive=NAIVE(logmove),
        drift=RW(logmove ~ drift()),
        arima=ARIMA(logmove ~ pdq() + PDQ(0, 0, 0))
    )
})

# next, fit models that require manual imputation (ETS)
oj_modelset_ets <- parallel::parLapply(cl, oj_train, function(df)
{
    df %>%
        fill(everything()) %>%
        model(ets=ETS(logmove ~ error("A") + trend("A") + season("N")))
})

parallel::stopCluster(cl)
save(oj_modelset, oj_modelset_ets, file="oj_modelset.Rdata")

head(oj_modelset[[1]])
head(oj_modelset_ets[[1]])
```

